(function() {
	'use strict';

	var WAGNER = this.WAGNER || {};

	WAGNER.shaders = {};

	WAGNER.loadShader = function( id, cb ) {
		var source = WAGNER.shaders[ id ];
		if ( cb ) cb(source);
		return source;
	};


WAGNER.shaders['art-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'float level( in float value, in float min, in float max ) {',
'return min / 255.0 + ( max - min ) * value / 255.0;',
'}',
'float gamma( in float value, in float g ) {',
'return pow( value, 1.0 / g );',
'}',
'void main(void) {',
'vec4 color = texture2D( tInput, vUv );',
'float r = color.r;',
'float g = color.g;',
'float b = color.b;',
'r = level( r, 0.0, 255.0 );',
'g = level( g, 0.0, 184.0 );',
'b = level( b, 0.0, 113.0 );',
'r = gamma( r, 1.10 );',
'g = gamma( g, 0.95 );',
'b = gamma( b, 1.04 );',
'r = level( r, 10.0, 240.0 );',
'g = level( g, 10.0, 240.0 );',
'b = level( b, 10.0, 240.0 );',
'r = gamma( r, 0.87 );',
'g = gamma( g, 0.87 );',
'b = gamma( b, 0.87 );',
'float yL = .2126 * color.r + .7152 * color.g + .0722 * color.b;',
'r += yL; g += yL; b += yL;',
'gl_FragColor = vec4( r, g, b, color.a );',
'}',
].join('\n');
WAGNER.shaders['ascii-fs'] = [
'varying vec2 vUv;',
'uniform vec2 resolution;',
'uniform sampler2D tInput;',
'uniform sampler2D tAscii;',
'const vec2 fontSize = vec2(8.0,16.0);',
'vec4 lookupASCII(float asciiValue){',
'vec2 pos = mod(gl_FragCoord.xy,fontSize.xy);',
'pos = pos / vec2(2048.0,16.0);',
'pos.x += asciiValue;',
'return vec4(texture2D(tAscii,pos).rgb,1.0);',
'}',
'void main(void) {',
'vec2 invViewport = vec2(1.0) / resolution;',
'vec2 pixelSize = fontSize;',
'vec4 sum = vec4(0.0);',
'vec2 uvClamped = vUv-mod(vUv,pixelSize * invViewport);',
'for (float x=0.0;x<fontSize.x;x++){',
'for (float y=0.0;y<fontSize.y;y++){',
'vec2 offset = vec2(x,y);',
'sum += texture2D(tInput,uvClamped+(offset*invViewport));',
'}',
'}',
'vec4 avarage = sum / vec4(fontSize.x*fontSize.y);',
'float brightness = (avarage.x+avarage.y+avarage.z)*0.33333;',
'vec4 clampedColor = floor(avarage*8.0)/8.0;',
'float asciiChar = floor((1.0-brightness)*256.0)/256.0;',
'gl_FragColor = clampedColor*lookupASCII(asciiChar);',
'}',
].join('\n');
WAGNER.shaders['barrel-blur-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'vec2 barrelDistortion(vec2 coord, float amt) {',
'vec2 cc = coord - 0.5;',
'float dist = dot(cc, cc);',
'return coord + cc * dist * amt;',
'}',
'void main() {',
'vec2 uv=(gl_FragCoord.xy/resolution.xy*.5)+.25;',
'vec4 a1=texture2D(tInput, barrelDistortion(uv,0.0));',
'vec4 a2=texture2D(tInput, barrelDistortion(uv,0.2));',
'vec4 a3=texture2D(tInput, barrelDistortion(uv,0.4));',
'vec4 a4=texture2D(tInput, barrelDistortion(uv,0.6));',
'vec4 a5=texture2D(tInput, barrelDistortion(uv,0.8));',
'vec4 a6=texture2D(tInput, barrelDistortion(uv,1.0));',
'vec4 a7=texture2D(tInput, barrelDistortion(uv,1.2));',
'vec4 a8=texture2D(tInput, barrelDistortion(uv,1.4));',
'vec4 a9=texture2D(tInput, barrelDistortion(uv,1.6));',
'vec4 a10=texture2D(tInput, barrelDistortion(uv,1.8));',
'vec4 a11=texture2D(tInput, barrelDistortion(uv,2.0));',
'vec4 a12=texture2D(tInput, barrelDistortion(uv,2.2));',
'vec4 tx=(a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12)/12.;',
'gl_FragColor = vec4(tx.rgb, tx.a );',
'}',
].join('\n');
WAGNER.shaders['bleach-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float amount;',
'varying vec2 vUv;',
'const vec4 one = vec4(1.0);',
'const vec4 two = vec4(2.0);',
'const vec4 lumcoeff = vec4(0.2125,0.7154,0.0721,0.0);',
'vec4 overlay(vec4 myInput, vec4 previousmix, vec4 amount) {',
'float luminance = dot(previousmix,lumcoeff);',
'float mixamount = clamp((luminance - 0.45) * 10.0, 0.0, 1.0);',
'vec4 branch1 = two * previousmix * myInput;',
'vec4 branch2 = one - (two * (one - previousmix) * (one - myInput));',
'vec4 result = mix(branch1, branch2, vec4(mixamount) );',
'return mix(previousmix, result, amount);',
'}',
'void main (void)  {',
'vec4 pixel = texture2D(tInput, vUv);',
'vec4 luma = vec4(vec3(dot(pixel,lumcoeff)), pixel.a);',
'gl_FragColor = overlay(luma, pixel, vec4(amount));',
'}',
].join('\n');
WAGNER.shaders['blend-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tInput2;',
'uniform vec2 resolution;',
'uniform vec2 resolution2;',
'uniform float aspectRatio;',
'uniform float aspectRatio2;',
'uniform int mode;',
'uniform int sizeMode;',
'uniform float opacity;',
'vec2 vUv2;',
'float applyOverlayToChannel( float base, float blend ) {',
'return (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));',
'}',
'float applySoftLightToChannel( float base, float blend ) {',
'return ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)));',
'}',
'float applyColorBurnToChannel( float base, float blend ) {',
'return ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0));',
'}',
'float applyColorDodgeToChannel( float base, float blend ) {',
'return ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0));',
'}',
'float applyLinearBurnToChannel( float base, float blend ) {',
'return max(base + blend - 1., 0.0 );',
'}',
'float applyLinearDodgeToChannel( float base, float blend ) {',
'return min( base + blend, 1. );',
'}',
'float applyLinearLightToChannel( float base, float blend ) {',
'return ( blend < .5 ) ? applyLinearBurnToChannel( base, 2. * blend ) : applyLinearDodgeToChannel( base, 2. * ( blend - .5 ) );',
'}',
'void main() {',
'vUv2 = vUv;',
'if( sizeMode == 1 ) {',
'if( aspectRatio2 > aspectRatio ) {',
'vUv2.x = vUv.x * aspectRatio / aspectRatio2;',
'vUv2.x += .5 * ( 1. - aspectRatio / aspectRatio2 );',
'vUv2.y = vUv.y;',
'}',
'if( aspectRatio2 < aspectRatio ) {',
'vUv2.x = vUv.x;',
'vUv2.y = vUv.y * aspectRatio2 / aspectRatio;',
'vUv2.y += .5 * ( 1. - aspectRatio2 / aspectRatio );',
'}',
'}',
'vec4 base = texture2D( tInput, vUv );',
'vec4 blend = texture2D( tInput2, vUv2 );',
'if( mode == 1 ) {',
'gl_FragColor = base;',
'gl_FragColor.a *= opacity;',
'return;',
'}',
'if( mode == 2 ) {',
'}',
'if( mode == 3 ) {',
'gl_FragColor = min( base, blend );',
'return;',
'}',
'if( mode == 4 ) {',
'gl_FragColor = base * blend;',
'return;',
'}',
'if( mode == 5 ) {',
'gl_FragColor = vec4(',
'applyColorBurnToChannel( base.r, blend.r ),',
'applyColorBurnToChannel( base.g, blend.g ),',
'applyColorBurnToChannel( base.b, blend.b ),',
'applyColorBurnToChannel( base.a, blend.a )',
');',
'return;',
'}',
'if( mode == 6 ) {',
'gl_FragColor = max(base + blend - 1.0, 0.0);',
'return;',
'}',
'if( mode == 7 ) {',
'}',
'if( mode == 8 ) {',
'gl_FragColor = max( base, blend );',
'return;',
'}',
'if( mode == 9 ) {',
'gl_FragColor = (1.0 - ((1.0 - base) * (1.0 - blend)));',
'gl_FragColor = gl_FragColor * opacity + base * ( 1. - opacity );',
'return;',
'}',
'if( mode == 10 ) {',
'gl_FragColor = vec4(',
'applyColorDodgeToChannel( base.r, blend.r ),',
'applyColorDodgeToChannel( base.g, blend.g ),',
'applyColorDodgeToChannel( base.b, blend.b ),',
'applyColorDodgeToChannel( base.a, blend.a )',
');',
'return;',
'}',
'if( mode == 11 ) {',
'gl_FragColor = min(base + blend, 1.0);',
'return;',
'}',
'if( mode == 12 ) {',
'}',
'if( mode == 13 ) {',
'gl_FragColor = gl_FragColor = vec4(',
'applyOverlayToChannel( base.r, blend.r ),',
'applyOverlayToChannel( base.g, blend.g ),',
'applyOverlayToChannel( base.b, blend.b ),',
'applyOverlayToChannel( base.a, blend.a )',
');',
'gl_FragColor = gl_FragColor * opacity + base * ( 1. - opacity );',
'return;',
'}',
'if( mode == 14 ) {',
'gl_FragColor = vec4(',
'applySoftLightToChannel( base.r, blend.r ),',
'applySoftLightToChannel( base.g, blend.g ),',
'applySoftLightToChannel( base.b, blend.b ),',
'applySoftLightToChannel( base.a, blend.a )',
');',
'return;',
'}',
'if( mode == 15 ) {',
'gl_FragColor = vec4(',
'applyOverlayToChannel( base.r, blend.r ),',
'applyOverlayToChannel( base.g, blend.g ),',
'applyOverlayToChannel( base.b, blend.b ),',
'applyOverlayToChannel( base.a, blend.a )',
');',
'gl_FragColor = gl_FragColor * opacity + base * ( 1. - opacity );',
'return;',
'}',
'if( mode == 16 ) {',
'}',
'if( mode == 17 ) {',
'gl_FragColor = vec4(',
'applyLinearLightToChannel( base.r, blend.r ),',
'applyLinearLightToChannel( base.g, blend.g ),',
'applyLinearLightToChannel( base.b, blend.b ),',
'applyLinearLightToChannel( base.a, blend.a )',
');',
'return;',
'}',
'if( mode == 18 ) {',
'}',
'if( mode == 19 ) {',
'}',
'if( mode == 20 ) {',
'gl_FragColor = abs( base - blend );',
'gl_FragColor.a = base.a + blend.b;',
'return;',
'}',
'if( mode == 21 ) {',
'gl_FragColor = base + blend - 2. * base * blend;',
'}',
'if( mode == 22 ) {',
'}',
'if( mode == 23 ) {',
'}',
'gl_FragColor = vec4( 1., 0., 1., 1. );',
'}',
].join('\n');
WAGNER.shaders['bloom-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'void main()',
'{',
'vec4 sum = vec4(0);',
'vec2 texcoord = vUv;',
'for( int i= -4 ;i < 4; i++)',
'{',
'for ( int j = -3; j < 3; j++)',
'{',
'sum += texture2D(tInput, texcoord + vec2(j, i)*0.004) * 0.25;',
'}',
'}',
'if (texture2D(tInput, texcoord).r < 0.3)',
'{',
'gl_FragColor = sum*sum*0.012 + texture2D(tInput, texcoord);',
'}',
'else',
'{',
'if (texture2D(tInput, texcoord).r < 0.5)',
'{',
'gl_FragColor = sum*sum*0.009 + texture2D(tInput, texcoord);',
'}',
'else',
'{',
'gl_FragColor = sum*sum*0.0075 + texture2D(tInput, texcoord);',
'}',
'}',
'}',
].join('\n');
WAGNER.shaders['bloom2-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'float kernel = .005;',
'float scale = 1.;',
'float thresh = 1.;',
'void main()',
'{',
'vec4 sum = vec4(0);',
'int j=-2;',
'for( int i=-2; i<=2; i++) sum+=texture2D(tInput,vUv+vec2(i,j)*kernel);',
'j=-1;',
'for( int i=-2; i<=2; i++) sum+=texture2D(tInput,vUv+vec2(i,j)*kernel);',
'j=0;',
'for( int i=-2; i<=2; i++) sum+=texture2D(tInput,vUv+vec2(i,j)*kernel);',
'j=1;',
'for( int i=-2; i<=2; i++) sum+=texture2D(tInput,vUv+vec2(i,j)*kernel);',
'j=2;',
'for( int i=-2; i<=2; i++) sum+=texture2D(tInput,vUv+vec2(i,j)*kernel);',
'sum/=25.0;',
'vec4 s=texture2D(tInput, vUv);',
'gl_FragColor=s;',
'if (length(sum)>thresh)',
'{',
'gl_FragColor +=sum*scale;',
'}',
'}',
].join('\n');
WAGNER.shaders['bokeh-poison-dof-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tBias;',
'uniform float radius;',
'uniform float amount;',
'uniform vec2 resolution;',
'uniform float focalDistance;',
'uniform float aperture;',
'#define ITERATIONS 150.0',
'#define ONEOVER_ITR  1.0 / ITERATIONS',
'#define PI 3.141596',
'#define GOLDEN_ANGLE 2.39996323',
'vec2 Sample(in float theta, inout float r)',
'{',
'r += 1.0 / r;',
'return (r-1.0) * vec2(cos(theta), sin(theta)) * .06;',
'}',
'vec3 Bokeh(sampler2D tex, vec2 uv, float radius, float amount)',
'{',
'vec3 acc = vec3(0.0);',
'vec3 div = vec3(0.0);',
'vec2 pixel = vec2(resolution.y/resolution.x, 1.0) * radius * .025;',
'float r = 1.0;',
'for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)',
'{',
'vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;',
'vec3 bokeh = vec3(.5) + pow(col, vec3(10.0)) * amount;',
'acc += col * bokeh;',
'div += bokeh;',
'}',
'return acc / div;',
'}',
'float sampleBias( vec2 uv ) {',
'float d = abs( texture2D( tBias, uv ).r - focalDistance );',
'return d * aperture;',
'}',
'void main(void)',
'{',
'vec2 uv = gl_FragCoord.xy / resolution.xy;',
'float bias = sampleBias( vUv );',
'gl_FragColor = vec4(Bokeh(tInput, uv*vec2(1.0, 1.0), radius * bias, amount ), 1.0);',
'}',
].join('\n');
WAGNER.shaders['bokeh-poison-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tBias;',
'uniform float radius;',
'uniform float amount;',
'uniform vec2 resolution;',
'#define ITERATIONS 150.0',
'#define ONEOVER_ITR  1.0 / ITERATIONS',
'#define PI 3.141596',
'#define GOLDEN_ANGLE 2.39996323',
'vec2 Sample(in float theta, inout float r)',
'{',
'r += 1.0 / r;',
'return (r-1.0) * vec2(cos(theta), sin(theta)) * .06;',
'}',
'vec3 Bokeh(sampler2D tex, vec2 uv, float radius, float amount)',
'{',
'vec3 acc = vec3(0.0);',
'vec3 div = vec3(0.0);',
'vec2 pixel = vec2(resolution.y/resolution.x, 1.0) * radius * .025;',
'float r = 1.0;',
'for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)',
'{',
'vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;',
'vec3 bokeh = vec3(.5) + pow(col, vec3(10.0)) * amount;',
'acc += col * bokeh;',
'div += bokeh;',
'}',
'return acc / div;',
'}',
'void main(void)',
'{',
'vec2 uv = gl_FragCoord.xy / resolution.xy;',
'gl_FragColor = vec4(Bokeh(tInput, uv*vec2(1.0, 1.0), radius * ( 1. - texture2D( tBias, uv ).r ), amount ), 1.0);',
'}',
].join('\n');
WAGNER.shaders['box-blur-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 delta;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'void main() {',
'vec4 color=vec4(0.0);',
'float total=0.0;',
'float offset=random(vec3(12.9898,78.233,151.7182),0.0);',
'for(float t=-30.0;t<=30.0;t++){',
'float percent=(t+offset-0.5)/30.0;',
'float weight=1.0-abs(percent);',
'vec4 sample=texture2D(tInput,vUv+delta*percent);',
'sample.rgb*=sample.a;',
'color+=sample*weight;',
'total+=weight;',
'}',
'gl_FragColor=color/total;',
'gl_FragColor.rgb/=gl_FragColor.a+0.00001;',
'}',
].join('\n');
WAGNER.shaders['box-blur2-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 delta;',
'uniform vec2 resolution;',
'void main() {',
'vec4 sum = vec4( 0. );',
'vec2 inc = delta / resolution;',
'sum += texture2D( tInput, ( vUv - inc * 4. ) ) * 0.051;',
'sum += texture2D( tInput, ( vUv - inc * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv - inc * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv - inc * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + inc * 0. ) ) * 0.1633;',
'sum += texture2D( tInput, ( vUv + inc * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + inc * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv + inc * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv + inc * 4. ) ) * 0.051;',
'gl_FragColor = sum;',
'}',
].join('\n');
WAGNER.shaders['brightness-contrast-fs'] = [
'uniform float brightness;',
'uniform float contrast;',
'uniform sampler2D tInput;',
'varying vec2 vUv;',
'void main() {',
'vec3 color = texture2D(tInput, vUv).rgb;',
'vec3 colorContrasted = (color) * contrast;',
'vec3 bright = colorContrasted + vec3(brightness,brightness,brightness);',
'gl_FragColor.rgb = bright;',
'gl_FragColor.a = 1.;',
'}',
].join('\n');
WAGNER.shaders['cga-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform sampler2D cgaMap;',
'uniform float pixelDensity;',
'void main() {',
'float size = 2. * pixelDensity;',
'float dSize = 2. * size;',
'float amount = resolution.x / size;',
'float d = 1.0 / amount;',
'float ar = resolution.x / resolution.y;',
'float sx = floor( vUv.x / d ) * d;',
'd = ar / amount;',
'float sy = floor( vUv.y / d ) * d;',
'vec4 base = texture2D( tInput, vec2( sx, sy ) );',
'float lum = .2126 * base.r + .7152 * base.g + .0722 * base.b;',
'float o = floor( 6. * lum );',
'vec3 c1;',
'vec3 c2;',
'vec3 black = vec3( 0. );',
'vec3 light = vec3( 85., 255., 255. ) / 255.;',
'vec3 dark = vec3( 254., 84., 255. ) / 255.;',
'vec3 white = vec3( 1. );',
'if( o == 0. ) { c1 = black; c2 = c1; }',
'if( o == 1. ) { c1 = black; c2 = dark; }',
'if( o == 2. ) { c1 = dark;  c2 = c1; }',
'if( o == 3. ) { c1 = dark;  c2 = light; }',
'if( o == 4. ) { c1 = light; c2 = c1; }',
'if( o == 5. ) { c1 = light; c2 = white; }',
'if( o == 6. ) { c1 = white; c2 = c1; }',
'if( mod( gl_FragCoord.x, dSize ) > size ) {',
'if( mod( gl_FragCoord.y, dSize ) > size ) {',
'base.rgb = c1;',
'} else {',
'base.rgb = c2;',
'}',
'} else {',
'if( mod( gl_FragCoord.y, dSize ) > size ) {',
'base.rgb = c2;',
'} else {',
'base.rgb = c1;',
'}',
'}',
'gl_FragColor = vec4( base.rgb, base.a );',
'}',
].join('\n');
WAGNER.shaders['chromatic-aberration-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'vec2 barrelDistortion(vec2 coord, float amt) {',
'vec2 cc = coord - 0.5;',
'float dist = dot(cc, cc);',
'return coord + cc * dist * amt;',
'}',
'float sat( float t )',
'{',
'return clamp( t, 0.0, 1.0 );',
'}',
'float linterp( float t ) {',
'return sat( 1.0 - abs( 2.0*t - 1.0 ) );',
'}',
'float remap( float t, float a, float b ) {',
'return sat( (t - a) / (b - a) );',
'}',
'vec4 spectrum_offset( float t ) {',
'vec4 ret;',
'float lo = step(t,0.5);',
'float hi = 1.0-lo;',
'float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );',
'ret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);',
'return pow( ret, vec4(1.0/2.2) );',
'}',
'const float max_distort = 2.2;',
'const int num_iter = 12;',
'const float reci_num_iter_f = 1.0 / float(num_iter);',
'void main()',
'{',
'vec2 uv=(gl_FragCoord.xy/resolution.xy*.5)+.25;',
'vec4 sumcol = vec4(0.0);',
'vec4 sumw = vec4(0.0);',
'for ( int i=0; i<num_iter;++i )',
'{',
'float t = float(i) * reci_num_iter_f;',
'vec4 w = spectrum_offset( t );',
'sumw += w;',
'sumcol += w * texture2D( tInput, barrelDistortion(uv, .6 * max_distort*t ) );',
'}',
'gl_FragColor = sumcol / sumw;',
'}',
].join('\n');
WAGNER.shaders['circular-blur-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'float nrand( vec2 n ) {',
'return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);',
'}',
'vec2 rot2d( vec2 p, float a ) {',
'vec2 sc = vec2(sin(a),cos(a));',
'return vec2( dot( p, vec2(sc.y, -sc.x) ), dot( p, sc.xy ) );',
'}',
'void main(void)',
'{',
'vec2 uv = gl_FragCoord.xy / resolution.xy;',
'uv.x += 0.1;',
'float maxofs = 12.0;',
'const int NUM_SAMPLES = 16;',
'const int NUM_SAMPLES2 = NUM_SAMPLES/2;',
'const float NUM_SAMPLES_F = float(NUM_SAMPLES);',
'const float anglestep = 6.28 / NUM_SAMPLES_F;',
'const float MIPBIAS = -8.0;',
'float rnd = nrand( 0.01*gl_FragCoord.xy );',
'vec2 ofs[NUM_SAMPLES];',
'{',
'float angle = 3.1416*rnd;',
'for( int i=0;i<NUM_SAMPLES2;++i )',
'{',
'ofs[i] = rot2d( vec2(maxofs,0.0), angle ) / resolution.xy;',
'angle += anglestep;',
'}',
'}',
'vec4 sum = vec4(0.0);',
'for( int i=0;i<NUM_SAMPLES2;++i )',
'sum += texture2D( tInput, vec2(uv.x, uv.y)+ofs[i], MIPBIAS );',
'for( int i=0;i<NUM_SAMPLES2;++i )',
'sum += texture2D( tInput, vec2(uv.x, uv.y)-ofs[i], MIPBIAS );',
'gl_FragColor.rgb = sum.rgb / NUM_SAMPLES_F;',
'gl_FragColor.a = texture2D( tInput, vUv ).a;',
'}',
].join('\n');
WAGNER.shaders['copy-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'void main() {',
'gl_FragColor = texture2D( tInput, vUv );',
'}',
].join('\n');
WAGNER.shaders['crossfade-fs'] = [
'uniform sampler2D tInput;',
'uniform sampler2D tInput2;',
'uniform sampler2D tFadeMap;',
'uniform vec2 resolution;',
'uniform float time;',
'uniform float amount;',
'varying vec2 vUv;',
'void main( void ) {',
'float range = .2;',
'vec4 from = texture2D( tInput, vUv );',
'vec4 to = texture2D( tInput2, vUv );',
'vec3 luma = vec3( .299, 0.587, 0.114 );',
'float v = clamp( dot( luma, texture2D( tFadeMap, vUv ).rgb ), 0., 1. - range );',
'float threshold = 0.1;',
'float r = amount * (1.0 + threshold * 2.0) - threshold;',
'float m = clamp((v - r)*(1.0/threshold), 0.0, 1.0);',
'gl_FragColor = mix( from, to, m );',
'}',
].join('\n');
WAGNER.shaders['denoise-fs'] = [
'uniform sampler2D tInput;',
'uniform float exponent;',
'uniform float strength;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'void main() {',
'vec4 center = texture2D(tInput, vUv);',
'vec4 color = vec4(0.0);',
'float total = 0.0;',
'for (float x = -4.0; x <= 4.0; x += 1.0) {',
'for (float y = -4.0; y <= 4.0; y += 1.0) {',
'vec4 sample = texture2D(tInput, vUv + vec2(x, y) / resolution);',
'float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));',
'weight = pow(weight, exponent);',
'color += sample * weight;',
'total += weight;',
'}',
'}',
'gl_FragColor = color / total;',
'}',
].join('\n');
WAGNER.shaders['dof-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tBias;',
'uniform float focalDistance;',
'uniform float aperture;',
'uniform float blurAmount;',
'uniform vec2 delta;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'float unpack_depth(const in vec4 color) {',
'return ( color.r * 256. * 256. * 256. + color.g * 256. * 256. + color.b * 256. + color.a ) / ( 256. * 256. * 256. );',
'}',
'float sampleBias( vec2 uv ) {',
'float d = abs( texture2D( tBias, uv ).r - focalDistance );',
'return min( d * aperture, .005 );',
'}',
'void main() {',
'vec4 sum = vec4( 0. );',
'float bias = sampleBias( vUv );',
'sum += texture2D( tInput, ( vUv - bias * delta * 4. ) ) * 0.051;',
'sum += texture2D( tInput, ( vUv - bias * delta * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv - bias * delta * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv - bias * delta * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + bias * delta * 0. ) ) * 0.1633;',
'sum += texture2D( tInput, ( vUv + bias * delta * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + bias * delta * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv + bias * delta * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv + bias * delta * 4. ) ) * 0.051;',
'gl_FragColor = sum;',
'}',
].join('\n');
WAGNER.shaders['dot-screen-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'vec2 center = .5 * resolution;',
'float angle = 1.57;',
'float scale = 1.;',
'float pattern() {',
'float s = sin( angle ), c = cos( angle );',
'vec2 tex = vUv * resolution - center;',
'vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;',
'return ( sin( point.x ) * sin( point.y ) ) * 4.0;',
'}',
'void main() {',
'vec4 color = texture2D( tInput, vUv );',
'float average = ( color.r + color.g + color.b ) / 3.0;',
'gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );',
'}',
].join('\n');
WAGNER.shaders['frei-chen-fs'] = [
'uniform sampler2D tInput;',
'varying vec2 vUv;',
'uniform vec2 resolution;',
'vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);',
'mat3 G[9];',
'const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );',
'const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );',
'const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );',
'const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );',
'const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );',
'const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );',
'const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );',
'const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );',
'const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );',
'void main(void) {',
'G[0] = g0,',
'G[1] = g1,',
'G[2] = g2,',
'G[3] = g3,',
'G[4] = g4,',
'G[5] = g5,',
'G[6] = g6,',
'G[7] = g7,',
'G[8] = g8;',
'mat3 I;',
'float cnv[9];',
'vec3 sample;',
'for (float i=0.0; i<3.0; i++) {',
'for (float j=0.0; j<3.0; j++) {',
'sample = texture2D(tInput, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;',
'I[int(i)][int(j)] = length(sample);',
'}',
'}',
'for (int i=0; i<9; i++) {',
'float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);',
'cnv[i] = dp3 * dp3;',
'}',
'float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);',
'float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);',
'gl_FragColor = vec4(vec3(sqrt(M/S)), texture2D( tInput, vUv ).a );',
'}',
].join('\n');
WAGNER.shaders['fxaa-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'#define FXAA_REDUCE_MIN   (1.0/128.0)',
'#define FXAA_REDUCE_MUL   (1.0/8.0)',
'#define FXAA_SPAN_MAX     8.0',
'void main() {',
'vec2 res = 1. / resolution;',
'vec3 rgbNW = texture2D( tInput, ( vUv.xy + vec2( -1.0, -1.0 ) * res ) ).xyz;',
'vec3 rgbNE = texture2D( tInput, ( vUv.xy + vec2( 1.0, -1.0 ) * res ) ).xyz;',
'vec3 rgbSW = texture2D( tInput, ( vUv.xy + vec2( -1.0, 1.0 ) * res ) ).xyz;',
'vec3 rgbSE = texture2D( tInput, ( vUv.xy + vec2( 1.0, 1.0 ) * res ) ).xyz;',
'vec4 rgbaM  = texture2D( tInput,  vUv.xy  * res );',
'vec3 rgbM  = rgbaM.xyz;',
'vec3 luma = vec3( 0.299, 0.587, 0.114 );',
'float lumaNW = dot( rgbNW, luma );',
'float lumaNE = dot( rgbNE, luma );',
'float lumaSW = dot( rgbSW, luma );',
'float lumaSE = dot( rgbSE, luma );',
'float lumaM  = dot( rgbM,  luma );',
'float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );',
'float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );',
'vec2 dir;',
'dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));',
'dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));',
'float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );',
'float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );',
'dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),',
'max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),',
'dir * rcpDirMin)) * res;',
'vec4 rgbA = (1.0/2.0) * (',
'texture2D(tInput,  vUv.xy + dir * (1.0/3.0 - 0.5)) +',
'texture2D(tInput,  vUv.xy + dir * (2.0/3.0 - 0.5)));',
'vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (',
'texture2D(tInput,  vUv.xy + dir * (0.0/3.0 - 0.5)) +',
'texture2D(tInput,  vUv.xy + dir * (3.0/3.0 - 0.5)));',
'float lumaB = dot(rgbB, vec4(luma, 0.0));',
'if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {',
'gl_FragColor = rgbA;',
'} else {',
'gl_FragColor = rgbB;',
'}',
'}',
].join('\n');
WAGNER.shaders['fxaa2-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'vec2 texcoordOffset = 1. / resolution;',
'vec4 vertTexcoord = vec4( vUv, 1., 1. );',
'void main() {',
'float FXAA_SPAN_MAX = 8.0;',
'float FXAA_REDUCE_MUL = 1.0/8.0;',
'float FXAA_REDUCE_MIN = (1.0/128.0);',
'vec3 rgbNW = texture2D(tInput, vertTexcoord.xy + (vec2(-1.0, -1.0) * texcoordOffset)).xyz;',
'vec3 rgbNE = texture2D(tInput, vertTexcoord.xy + (vec2(+1.0, -1.0) * texcoordOffset)).xyz;',
'vec3 rgbSW = texture2D(tInput, vertTexcoord.xy + (vec2(-1.0, +1.0) * texcoordOffset)).xyz;',
'vec3 rgbSE = texture2D(tInput, vertTexcoord.xy + (vec2(+1.0, +1.0) * texcoordOffset)).xyz;',
'vec3 rgbM  = texture2D(tInput, vertTexcoord.xy).xyz;',
'vec3 luma = vec3(0.299, 0.587, 0.114);',
'float lumaNW = dot(rgbNW, luma);',
'float lumaNE = dot(rgbNE, luma);',
'float lumaSW = dot(rgbSW, luma);',
'float lumaSE = dot(rgbSE, luma);',
'float lumaM  = dot( rgbM, luma);',
'float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));',
'float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));',
'vec2 dir;',
'dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));',
'dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));',
'float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);',
'float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);',
'dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX),',
'max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * texcoordOffset;',
'vec3 rgbA = (1.0/2.0) * (',
'texture2D(tInput, vertTexcoord.xy + dir * (1.0/3.0 - 0.5)).xyz +',
'texture2D(tInput, vertTexcoord.xy + dir * (2.0/3.0 - 0.5)).xyz);',
'vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (',
'texture2D(tInput, vertTexcoord.xy + dir * (0.0/3.0 - 0.5)).xyz +',
'texture2D(tInput, vertTexcoord.xy + dir * (3.0/3.0 - 0.5)).xyz);',
'float lumaB = dot(rgbB, luma);',
'if((lumaB < lumaMin) || (lumaB > lumaMax)){',
'gl_FragColor.xyz=rgbA;',
'} else {',
'gl_FragColor.xyz=rgbB;',
'}',
'gl_FragColor.a = 1.0;',
'}',
].join('\n');
WAGNER.shaders['grayscale-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'void main() {',
'vec3 luma = vec3( .299, 0.587, 0.114 );',
'vec4 color = texture2D( tInput, vUv );',
'gl_FragColor = vec4( vec3( dot( color.rgb, luma ) ), color.a );',
'}',
].join('\n');
WAGNER.shaders['guided-box-blur-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tBias;',
'uniform vec2 delta;',
'uniform float invertBiasMap;',
'uniform float isPacked;',
'uniform float from;',
'uniform float to;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'float unpack_depth(const in vec4 color) {',
'return ( color.r * 256. * 256. * 256. + color.g * 256. * 256. + color.b * 256. + color.a ) / ( 256. * 256. * 256. );',
'}',
'float sampleBias( vec2 uv ) {',
'return smoothstep( from, to, texture2D( tBias, uv ).r );',
'}',
'void main() {',
'float f = sampleBias( vUv );',
'if( invertBiasMap == 1. ) f = 1. - f;',
'vec4 o = texture2D( tInput,vUv );',
'vec4 color=vec4(0.0);',
'float total=0.0;',
'vec2 tDelta = f * delta;',
'float offset=random(vec3(12.9898,78.233,151.7182),0.0);',
'for(float t=-30.0;t<=30.0;t++){',
'float percent=(t+offset-0.5)/30.0;',
'float weight=1.0-abs(percent);',
'vec4 sample=texture2D(tInput,vUv+tDelta*percent);',
'sample.rgb*=sample.a;',
'color+=sample*weight;',
'total+=weight;',
'}',
'if( total == 0. ) total = 1.;',
'gl_FragColor = mix( o, color/total, f );',
'gl_FragColor.rgb/=gl_FragColor.a+0.00001;',
'}',
].join('\n');
WAGNER.shaders['guided-box-blur2-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tBias;',
'uniform vec2 delta;',
'uniform float invertBiasMap;',
'uniform float isPacked;',
'uniform float from;',
'uniform float to;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'float unpack_depth(const in vec4 color) {',
'return ( color.r * 256. * 256. * 256. + color.g * 256. * 256. + color.b * 256. + color.a ) / ( 256. * 256. * 256. );',
'}',
'float sampleBias( vec2 uv ) {',
'float b = ( texture2D( tBias, uv ).r - from ) / ( to - from );',
'b = clamp( b, 0., 1. );',
'if( invertBiasMap == 1. ) b = 1. - b;',
'return b;',
'}',
'void main() {',
'vec4 sum = vec4( 0. );',
'float bias = sampleBias( vUv );',
'sum += texture2D( tInput, ( vUv - bias * delta * 4. ) ) * 0.051;',
'sum += texture2D( tInput, ( vUv - bias * delta * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv - bias * delta * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv - bias * delta * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + bias * delta * 0. ) ) * 0.1633;',
'sum += texture2D( tInput, ( vUv + bias * delta * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + bias * delta * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv + bias * delta * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv + bias * delta * 4. ) ) * 0.051;',
'gl_FragColor = sum;',
'}',
].join('\n');
WAGNER.shaders['guided-directional-blur-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform sampler2D tBias;',
'uniform float delta;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'float sampleBias( vec2 uv ) {',
'vec3 luma = vec3( .299, 0.587, 0.114 );',
'return dot( texture2D( tBias, uv ).rgb, luma );',
'}',
'void main() {',
'float f = sampleBias( vUv );',
'float a = - f * 3.14159;',
'vec4 o = texture2D( tInput,vUv );',
'vec4 color=vec4(0.0);',
'float total=0.0;',
'vec2 tDelta = delta * vec2( cos( a ), sin( a ) );',
'float offset=random(vec3(12.9898,78.233,151.7182),0.0);',
'for(float t=-30.0;t<=30.0;t++){',
'float percent=(t+offset-0.5)/30.0;',
'float weight=1.0-abs(percent);',
'vec4 sample=texture2D(tInput,vUv+tDelta*percent);',
'sample.rgb*=sample.a;',
'color+=sample*weight;',
'total+=weight;',
'}',
'if( total == 0. ) total = 1.;',
'gl_FragColor = color / total;',
'gl_FragColor.rgb/=gl_FragColor.a+0.00001;',
'}',
].join('\n');
WAGNER.shaders['halftone-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float pixelSize;',
'void main(void) {',
'vec2 p = vUv;',
'float pixelsPerRow = resolution.x / pixelSize;',
'float pixelsPerCol = resolution.y / pixelSize;',
'float pixelSizeX = 1.0 / pixelsPerRow;',
'float dx = mod(p.x, pixelSizeX ) - pixelSizeX *0.5;',
'float pixelSizeY = 1.0 / pixelsPerCol;',
'float dy = mod(p.y, pixelSizeY ) - pixelSizeY * 0.5;',
'float pixelSize = pixelSizeX;',
'p.x -= dx;',
'p.y -= dy;',
'vec3 col = texture2D(tInput, p).rgb;',
'vec3 luma = vec3( .299, 0.587, 0.114 );',
'float bright = dot( col.rgb, luma );',
'float dist = sqrt(dx*dx + dy*dy);',
'float rad = bright * pixelSize * 1.;',
'float m = step( dist, rad );',
'vec3 col2 = mix(vec3(0.0), vec3(1.0), m);',
'gl_FragColor = vec4(col2, 1.0);',
'}',
].join('\n');
WAGNER.shaders['halftone2-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float pixelSize;',
'uniform float amount;',
'uniform float smoothness;',
'float antialiasStep( float threshold, float value ) {',
'float afwidth = amount * ( 1.0 / 200.0 );',
'return smoothstep( threshold - afwidth, threshold, value );',
'}',
'float roundedBox( vec2 position, vec2 size, float radius ) {',
'return length( max( abs( position ) - size, 0.0 ) ) - radius;',
'}',
'void main(void) {',
'float ar = resolution.x / resolution.y;',
'vec2 nearest = 2.0 * fract( amount * vec2( 1., 1. / ar ) * vUv ) - 1.0;',
'float distX = length( nearest.x );',
'float distY = length( nearest.y );',
'float dist = length( nearest );',
'vec2 d = vec2( 1. / amount ) * vec2( 1., ar );',
'vec2 tUv = floor( vUv / d ) * d;',
'vec3 dotColorCalculation = texture2D( tInput, tUv ).rgb;',
'vec3 luma = vec3( .299, 0.587, 0.114 );',
'vec3 gradientColor = dotColorCalculation ;',
'float radius = sqrt( dot( dotColorCalculation, luma ) );',
'vec3 bkgColor = vec3( 0. );',
'vec4 halfToneDotColor = vec4( mix( gradientColor.rgb, bkgColor, antialiasStep( radius, dist ) ), 1.0 );',
'float b = roundedBox( vec2( distX+0.02, distY+0.02 ), vec2( .5 * radius ), 0.4 * radius );',
'vec4 halfToneSquircleColor = vec4( mix( bkgColor, gradientColor.rgb, smoothstep( smoothness, 0.0, b) ), 1.0 );',
'gl_FragColor = halfToneSquircleColor;',
'}',
].join('\n');
WAGNER.shaders['high-pass-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'float step_w = 1.0/resolution.x;',
'float step_h = 1.0/resolution.y;',
'void main(void)',
'{',
'vec2 offset[9];',
'float kernel[ 9 ];',
'offset[ 0 ] = vec2(-step_w, -step_h);',
'offset[ 1 ] = vec2(0.0, -step_h);',
'offset[ 2 ] = vec2(step_w, -step_h);',
'offset[ 3 ] = vec2(-step_w, 0.0);',
'offset[ 4 ] = vec2(0.0, 0.0);',
'offset[ 5 ] = vec2(step_w, 0.0);',
'offset[ 6 ] = vec2(-step_w, step_h);',
'offset[ 7 ] = vec2(0.0, step_h);',
'offset[ 8 ] = vec2(step_w, step_h);',
'kernel[ 0 ] = -1.;',
'kernel[ 1 ] = -1.;',
'kernel[ 2 ] = -1.;',
'kernel[ 3 ] = -1.;',
'kernel[ 4 ] = 8.;',
'kernel[ 5 ] = -1.;',
'kernel[ 6 ] = -1.;',
'kernel[ 7 ] = -1.;',
'kernel[ 8 ] = -1.;',
'int i = 0;',
'vec4 sum = vec4(0.0);',
'for( int i=0; i<9; i++ )',
'{',
'vec4 tmp = texture2D(tInput, vUv + offset[i]);',
'sum += tmp * kernel[i];',
'sum.a = 1.0;',
'}',
'gl_FragColor = sum;',
'}',
].join('\n');
WAGNER.shaders['invert-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'void main() {',
'gl_FragColor = texture2D( tInput, vUv );',
'gl_FragColor.rgb = 1. - gl_FragColor.rgb;',
'}',
].join('\n');
WAGNER.shaders['led-fs'] = [
'#define KERNEL_SIZE 9',
'uniform int pixelSize;',
'uniform vec2 resolution;',
'uniform sampler2D tInput;',
'uniform float tolerance;',
'uniform float pixelRadius;',
'uniform int luminanceSteps;',
'uniform float luminanceBoost;',
'uniform float colorBoost;',
'uniform float burntOutPercent;',
'uniform sampler2D noiseTexture;',
'varying vec2 vUv;',
'vec2 texCoords[KERNEL_SIZE];',
'float getIntensity(in vec4 color)',
'{ return (color.r + color.g + color.b)/3.0; }',
'vec4 applyColorBoost(in vec4 color)',
'{',
'vec4 boostedColor = color;',
'float max = max(color.r,max(color.g, color.b));',
'bvec3 maxes = equal(vec3(color),vec3(max));',
'if(maxes.r)',
'boostedColor += vec4(2.0*colorBoost,-colorBoost,-colorBoost,0.0);',
'if(maxes.g)',
'boostedColor += vec4(-colorBoost,2.0*colorBoost,-colorBoost,0.0);',
'if(maxes.b)',
'boostedColor += vec4(-colorBoost,-colorBoost,2.0*colorBoost,0.0);',
'return boostedColor;',
'}',
'vec4 applyLuminanceStepping(in vec4 color)',
'{',
'float sum = color.r + color.g + color.b;',
'float luminance = sum/3.0;',
'vec3 ratios = vec3(color.r/luminance, color.g/luminance, color.b/luminance);',
'float luminanceStep = 1.0/float(luminanceSteps);',
'float luminanceBin = ceil(luminance/luminanceStep);',
'float luminanceFactor = luminanceStep * luminanceBin + luminanceBoost;',
'return vec4(ratios * luminanceFactor,1.0);',
'}',
'void main(void)',
'{',
'vec4 avgColor;',
'vec2 texCoordsStep = 1.0/(vec2(float(resolution.x),float(resolution.y))/float(pixelSize));',
'vec2 pixelRegionCoords = fract( vUv/texCoordsStep);',
'vec2 pixelBin = floor( vUv/texCoordsStep);',
'vec2 inPixelStep = texCoordsStep/3.0;',
'vec2 inPixelHalfStep = inPixelStep/2.0;',
'texCoords[4] = vec2(inPixelStep.x + inPixelHalfStep.x, inPixelStep.y + inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[0] = vec2(inPixelHalfStep.x, inPixelStep.y*2.0 + inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[1] = vec2(inPixelStep.x + inPixelHalfStep.x, inPixelStep.y*2.0 + inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[2] = vec2(inPixelStep.x*2.0 + inPixelHalfStep.x, inPixelStep.y*2.0 + inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[3] = vec2(inPixelHalfStep.x, inPixelStep.y + inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[5] = vec2(inPixelStep.x*2.0 + inPixelHalfStep.x, inPixelStep.y + inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[6] = vec2(inPixelHalfStep.x, inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[7] = vec2(inPixelStep.x + inPixelHalfStep.x, inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'texCoords[8] = vec2(inPixelStep.x*2.0 + inPixelHalfStep.x, inPixelHalfStep.y) + pixelBin * texCoordsStep;',
'avgColor = texture2D(tInput, texCoords[0]) +',
'texture2D(tInput, texCoords[1]) +',
'texture2D(tInput, texCoords[2]) +',
'texture2D(tInput, texCoords[3]) +',
'texture2D(tInput, texCoords[4]) +',
'texture2D(tInput, texCoords[5]) +',
'texture2D(tInput, texCoords[6]) +',
'texture2D(tInput, texCoords[7]) +',
'texture2D(tInput, texCoords[8]);',
'avgColor /= float(KERNEL_SIZE);',
'avgColor = applyLuminanceStepping(avgColor);',
'avgColor = applyColorBoost(avgColor);',
'vec2 powers = pow(abs(pixelRegionCoords - 0.5),vec2(2.0));',
'float radiusSqrd = pow(pixelRadius,2.0);',
'float gradient = smoothstep(radiusSqrd-tolerance, radiusSqrd+tolerance, powers.x+powers.y);',
'gl_FragColor = mix(avgColor, vec4(0.1,0.1,0.1,1.0), gradient);',
'}',
].join('\n');
WAGNER.shaders['noise-fs'] = [
'uniform sampler2D tInput;',
'uniform float amount;',
'uniform float speed;',
'uniform float time;',
'varying vec2 vUv;',
'float random(vec2 n, float offset ){',
'return .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);',
'}',
'void main() {',
'vec4 color = texture2D(tInput, vUv);',
'color += vec4( vec3( amount * random( vUv, .00001 * speed * time ) ), 1. );',
'gl_FragColor = color;',
'}',
].join('\n');
WAGNER.shaders['old-video-fs'] = [
'#define BLACK_AND_WHITE',
'#define LINES_AND_FLICKER',
'#define BLOTCHES',
'#define GRAIN',
'#define FREQUENCY 15.0',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float time;',
'vec2 uv;',
'float rand(vec2 co){',
'return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);',
'}',
'float rand(float c){',
'return rand(vec2(c,1.0));',
'}',
'float randomLine(float seed)',
'{',
'float b = 0.01 * rand(seed);',
'float a = rand(seed+1.0);',
'float c = rand(seed+2.0) - 0.5;',
'float mu = rand(seed+3.0);',
'float l = 1.0;',
'if ( mu > 0.2)',
'l = pow(  abs(a * uv.x + b * uv.y + c ), 1.0/8.0 );',
'else',
'l = 2.0 - pow( abs(a * uv.x + b * uv.y + c), 1.0/8.0 );',
'return mix(0.5, 1.0, l);',
'}',
'float randomBlotch(float seed)',
'{',
'float x = rand(seed);',
'float y = rand(seed+1.0);',
'float s = 0.01 * rand(seed+2.0);',
'vec2 p = vec2(x,y) - uv;',
'p.x *= resolution.x / resolution.y;',
'float a = atan(p.y,p.x);',
'float v = 1.0;',
'float ss = s*s * (sin(6.2831*a*x)*0.1 + 1.0);',
'if ( dot(p,p) < ss ) v = 0.2;',
'else',
'v = pow(dot(p,p) - ss, 1.0/16.0);',
'return mix(0.3 + 0.2 * (1.0 - (s / 0.02)), 1.0, v);',
'}',
'void main(void)',
'{',
'uv = gl_FragCoord.xy / resolution.xy;',
'float t = float(int(time * FREQUENCY));',
'vec2 suv = uv + 0.002 * vec2( rand(t), rand(t + 23.0));',
'vec3 image = texture2D( tInput, vec2(suv.x, suv.y) ).xyz;',
'#ifdef BLACK_AND_WHITE',
'float luma = dot( vec3(0.2126, 0.7152, 0.0722), image );',
'vec3 oldImage = luma * vec3(0.7, 0.7, 0.7);',
'#else',
'vec3 oldImage = image;',
'#endif',
'float vI = 16.0 * (uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y));',
'vI *= mix( 0.7, 1.0, rand(t + 0.5));',
'vI += 1.0 + 0.4 * rand(t+8.);',
'vI *= pow(16.0 * uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y), 0.4);',
'#ifdef LINES_AND_FLICKER',
'int l = int(8.0 * rand(t+7.0));',
'if ( 0 < l ) vI *= randomLine( t+6.0+17.* float(0));',
'if ( 1 < l ) vI *= randomLine( t+6.0+17.* float(1));',
'if ( 2 < l ) vI *= randomLine( t+6.0+17.* float(2));',
'if ( 3 < l ) vI *= randomLine( t+6.0+17.* float(3));',
'if ( 4 < l ) vI *= randomLine( t+6.0+17.* float(4));',
'if ( 5 < l ) vI *= randomLine( t+6.0+17.* float(5));',
'if ( 6 < l ) vI *= randomLine( t+6.0+17.* float(6));',
'if ( 7 < l ) vI *= randomLine( t+6.0+17.* float(7));',
'#endif',
'#ifdef BLOTCHES',
'int s = int( max(8.0 * rand(t+18.0) -2.0, 0.0 ));',
'if ( 0 < s ) vI *= randomBlotch( t+6.0+19.* float(0));',
'if ( 1 < s ) vI *= randomBlotch( t+6.0+19.* float(1));',
'if ( 2 < s ) vI *= randomBlotch( t+6.0+19.* float(2));',
'if ( 3 < s ) vI *= randomBlotch( t+6.0+19.* float(3));',
'if ( 4 < s ) vI *= randomBlotch( t+6.0+19.* float(4));',
'if ( 5 < s ) vI *= randomBlotch( t+6.0+19.* float(5));',
'#endif',
'gl_FragColor.xyz = oldImage * vI;',
'#ifdef GRAIN',
'gl_FragColor.xyz *= (1.0+(rand(uv+t*.01)-.2)*.15);',
'#endif',
'}',
].join('\n');
WAGNER.shaders['packed-depth-fs'] = [
'uniform float mNear;',
'uniform float mFar;',
'uniform float isPacked;',
'varying float depth;',
'vec4 pack_depth( const in float f ) {',
'vec4 color;',
'color.r = floor( f / ( 256. * 256. * 256. ) );',
'color.g = floor( ( mod( f,  256. * 256. * 256. ) ) / ( 256. * 256. ) );',
'color.b = floor( ( mod( f,  256. * 256. ) ) / 256. );',
'color.a = floor( mod( f, 256.)  );',
'return color / 256.0;',
'}',
'void main() {',
'gl_FragColor = vec4( vec3( 1. - depth ), 1. );',
'}',
].join('\n');
WAGNER.shaders['pixelate-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float amount;',
'void main() {',
'float d = 1.0 / amount;',
'float ar = resolution.x / resolution.y;',
'float u = floor( vUv.x / d ) * d;',
'd = ar / amount;',
'float v = floor( vUv.y / d ) * d;',
'gl_FragColor = texture2D( tInput, vec2( u, v ) );',
'}',
].join('\n');
WAGNER.shaders['poisson-disc-blur-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'float nrand( vec2 n ) {',
'return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);',
'}',
'vec2 rot2d( vec2 p, float a ) {',
'vec2 sc = vec2(sin(a),cos(a));',
'return vec2( dot( p, vec2(sc.y, -sc.x) ), dot( p, sc.xy ) );',
'}',
'void main(void)',
'{',
'const int NUM_TAPS = 12;',
'float max_siz = 42.0;',
'vec2 fTaps_Poisson[NUM_TAPS];',
'fTaps_Poisson[0]  = vec2(-.326,-.406);',
'fTaps_Poisson[1]  = vec2(-.840,-.074);',
'fTaps_Poisson[2]  = vec2(-.696, .457);',
'fTaps_Poisson[3]  = vec2(-.203, .621);',
'fTaps_Poisson[4]  = vec2( .962,-.195);',
'fTaps_Poisson[5]  = vec2( .473,-.480);',
'fTaps_Poisson[6]  = vec2( .519, .767);',
'fTaps_Poisson[7]  = vec2( .185,-.893);',
'fTaps_Poisson[8]  = vec2( .507, .064);',
'fTaps_Poisson[9]  = vec2( .896, .412);',
'fTaps_Poisson[10] = vec2(-.322,-.933);',
'fTaps_Poisson[11] = vec2(-.792,-.598);',
'vec2 uv = gl_FragCoord.xy / resolution.xy;',
'vec4 sum = vec4(0);',
'float rnd = 6.28 * nrand( uv /*+fract(iGlobalTime)*/ );',
'vec4 basis = vec4( rot2d(vec2(1,0),rnd), rot2d(vec2(0,1),rnd) );',
'for (int i=0; i < NUM_TAPS; i++)',
'{',
'vec2 ofs = fTaps_Poisson[i]; ofs = vec2(dot(ofs,basis.xz),dot(ofs,basis.yw) );',
'vec2 texcoord = uv + max_siz * ofs / resolution.xy;',
'sum += texture2D(tInput, texcoord, -10.0);',
'}',
'gl_FragColor = sum / vec4(NUM_TAPS);',
'}',
].join('\n');
WAGNER.shaders['rgb-split-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 delta;',
'uniform vec2 resolution;',
'void main() {',
'vec2 dir = vUv - vec2( .5 );',
'float d = .7 * length( dir );',
'normalize( dir );',
'vec2 value = d * dir * delta;',
'vec4 c1 = texture2D( tInput, vUv - value / resolution.x );',
'vec4 c2 = texture2D( tInput, vUv );',
'vec4 c3 = texture2D( tInput, vUv + value / resolution.y );',
'gl_FragColor = vec4( c1.r, c2.g, c3.b, c1.a + c2.a + c3.b );',
'}',
].join('\n');
WAGNER.shaders['sepia-fs'] = [
'uniform sampler2D tInput;',
'uniform float amount;',
'varying vec2 vUv;',
'void main() {',
'vec4 color = texture2D(tInput, vUv);',
'float r = color.r;',
'float g = color.g;',
'float b = color.b;',
'color.r = min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));',
'color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));',
'color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));',
'gl_FragColor = color;',
'}',
].join('\n');
WAGNER.shaders['sobel-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'void main(void) {',
'float x = 1.0 / resolution.x;',
'float y = 1.0 / resolution.y;',
'vec4 horizEdge = vec4( 0.0 );',
'horizEdge -= texture2D( tInput, vec2( vUv.x - x, vUv.y - y ) ) * 1.0;',
'horizEdge -= texture2D( tInput, vec2( vUv.x - x, vUv.y     ) ) * 2.0;',
'horizEdge -= texture2D( tInput, vec2( vUv.x - x, vUv.y + y ) ) * 1.0;',
'horizEdge += texture2D( tInput, vec2( vUv.x + x, vUv.y - y ) ) * 1.0;',
'horizEdge += texture2D( tInput, vec2( vUv.x + x, vUv.y     ) ) * 2.0;',
'horizEdge += texture2D( tInput, vec2( vUv.x + x, vUv.y + y ) ) * 1.0;',
'vec4 vertEdge = vec4( 0.0 );',
'vertEdge -= texture2D( tInput, vec2( vUv.x - x, vUv.y - y ) ) * 1.0;',
'vertEdge -= texture2D( tInput, vec2( vUv.x    , vUv.y - y ) ) * 2.0;',
'vertEdge -= texture2D( tInput, vec2( vUv.x + x, vUv.y - y ) ) * 1.0;',
'vertEdge += texture2D( tInput, vec2( vUv.x - x, vUv.y + y ) ) * 1.0;',
'vertEdge += texture2D( tInput, vec2( vUv.x    , vUv.y + y ) ) * 2.0;',
'vertEdge += texture2D( tInput, vec2( vUv.x + x, vUv.y + y ) ) * 1.0;',
'vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));',
'gl_FragColor = vec4( edge, texture2D( tInput, vUv ).a );',
'}',
].join('\n');
WAGNER.shaders['sobel2-fs'] = [
'uniform sampler2D tInput;',
'varying vec2 vUv;',
'uniform vec2 resolution;',
'vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);',
'mat3 G[2];',
'const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );',
'const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );',
'void main(void) {',
'mat3 I;',
'float cnv[2];',
'vec3 sample;',
'G[0] = g0;',
'G[1] = g1;',
'for (float i=0.0; i<3.0; i++) {',
'for (float j=0.0; j<3.0; j++) {',
'sample = texture2D( tInput, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;',
'I[int(i)][int(j)] = length(sample);',
'}',
'}',
'for (int i=0; i<2; i++) {',
'float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);',
'cnv[i] = dp3 * dp3;',
'}',
'gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));',
'}',
].join('\n');
WAGNER.shaders['ssao-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tDepth;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float isPacked;',
'uniform float onlyOcclusion;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'float unpack_depth(const in vec4 color) {',
'return ( color.r * 256. * 256. * 256. + color.g * 256. * 256. + color.b * 256. + color.a ) / ( 256. * 256. * 256. );',
'}',
'float sampleDepth( vec2 uv ) {',
'if( isPacked == 1. ) {',
'return unpack_depth( texture2D( tDepth, uv ) );',
'} else {',
'return texture2D( tDepth, uv ).r;',
'}',
'}',
'float occlusion = 0.;',
'float depth = sampleDepth( vUv );',
'float ac = 0.;',
'void checkDepth( vec2 uv ) {',
'float zd = 10.0 * min( depth - sampleDepth( uv ), 0.0 );',
'ac += zd;',
'occlusion += 1.0 / ( 1. + zd * zd );',
'}',
'void main() {',
'float r = 4.;',
'float xi = r / resolution.x;',
'float yi = r / resolution.y;',
'checkDepth( vUv + vec2( - 2. * xi, - 2. * yi ) );',
'checkDepth( vUv + vec2(      - xi, - 2. * yi ) );',
'checkDepth( vUv + vec2(        0., - 2. * yi ) );',
'checkDepth( vUv + vec2(        xi, - 2. * yi ) );',
'checkDepth( vUv + vec2(   2. * xi, - 2. * yi ) );',
'checkDepth( vUv + vec2( - 2. * xi, - yi ) );',
'checkDepth( vUv + vec2(      - xi, - yi ) );',
'checkDepth( vUv + vec2(        0., - yi ) );',
'checkDepth( vUv + vec2(        xi, - yi ) );',
'checkDepth( vUv + vec2(   2. * xi, - yi ) );',
'checkDepth( vUv + vec2( - 2. * xi, 0. ) );',
'checkDepth( vUv + vec2(      - xi, 0. ) );',
'checkDepth( vUv + vec2(        xi, 0. ) );',
'checkDepth( vUv + vec2(   2. * xi, 0. ) );',
'checkDepth( vUv + vec2( - 2. * xi, yi ) );',
'checkDepth( vUv + vec2(      - xi, yi ) );',
'checkDepth( vUv + vec2(        0., yi ) );',
'checkDepth( vUv + vec2(        xi, yi ) );',
'checkDepth( vUv + vec2(   2. * xi, yi ) );',
'checkDepth( vUv + vec2( - 2. * xi, 2. * yi ) );',
'checkDepth( vUv + vec2(      - xi, 2. * yi ) );',
'checkDepth( vUv + vec2(        0., 2. * yi ) );',
'checkDepth( vUv + vec2(        xi, 2. * yi ) );',
'checkDepth( vUv + vec2(   2. * xi, 2. * yi ) );',
'occlusion /= 24.;',
'occlusion += .02 * random( vec3( gl_FragCoord.xy, depth ), length( gl_FragCoord ) );',
'float inBlack = 0.;',
'float inWhite = 255.;',
'float inGamma = 10.;',
'float outBlack = 0.;',
'float outWhite = 255.;',
'gl_FragColor = vec4( vec3( occlusion ), 1. );',
'}',
].join('\n');
WAGNER.shaders['ssao-simple-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tDepth;',
'uniform vec2 resolution;',
'uniform float zNear;',
'uniform float zFar;',
'uniform float strength;',
'#define PI    3.14159265',
'float width = resolution.x;',
'float height = resolution.y;',
'vec2 texCoord = vUv;',
'uniform int samples;',
'uniform float radius;',
'float aoclamp = 0.125;',
'bool noise = true;',
'float noiseamount = 0.0002;',
'float diffarea = 0.3;',
'float gdisplace = 0.4;',
'bool mist = false;',
'float miststart = 0.0;',
'float mistend = zFar;',
'bool onlyAO = false;',
'float lumInfluence = 0.7;',
'vec2 rand(vec2 coord)',
'{',
'float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;',
'float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;',
'if (noise)',
'{',
'noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;',
'noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;',
'}',
'return vec2(noiseX,noiseY)*noiseamount;',
'}',
'float doMist()',
'{',
'float zdepth = texture2D(tDepth,texCoord.xy).x;',
'float depth = -zFar * zNear / (zdepth * (zFar - zNear) - zFar);',
'return clamp((depth-miststart)/mistend,0.0,1.0);',
'}',
'float readDepth(vec2 coord)',
'{',
'if (vUv.x<0.0||vUv.y<0.0) return 1.0;',
'else {',
'float z_b = texture2D(tDepth, coord ).x;',
'float z_n = 2.0 * z_b - 1.0;',
'return (2.0 * zNear) / (zFar + zNear - z_n * (zFar-zNear));',
'}',
'}',
'int compareDepthsFar(float depth1, float depth2) {',
'float garea = 2.0;',
'float diff = (depth1 - depth2)*100.0;',
'if (diff<gdisplace)',
'{',
'return 0;',
'} else {',
'return 1;',
'}',
'}',
'float compareDepths(float depth1, float depth2)',
'{',
'float garea = 2.0;',
'float diff = (depth1 - depth2)*100.0;',
'if (diff<gdisplace)',
'{',
'garea = diffarea;',
'}',
'float gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));',
'return gauss;',
'}',
'float calAO(float depth,float dw, float dh)',
'{',
'float dd = (1.0-depth)*radius;',
'float temp = 0.0;',
'float temp2 = 0.0;',
'float coordw = vUv.x + dw*dd;',
'float coordh = vUv.y + dh*dd;',
'float coordw2 = vUv.x - dw*dd;',
'float coordh2 = vUv.y - dh*dd;',
'vec2 coord = vec2(coordw , coordh);',
'vec2 coord2 = vec2(coordw2, coordh2);',
'float cd = readDepth(coord);',
'int far = compareDepthsFar(depth, cd);',
'temp = compareDepths(depth, cd);',
'if (far > 0)',
'{',
'temp2 = compareDepths(readDepth(coord2),depth);',
'temp += (1.0-temp)*temp2;',
'}',
'return temp;',
'}',
'void main(void)',
'{',
'vec2 noise = rand(texCoord);',
'float depth = readDepth(texCoord);',
'float w = (1.0 / width)/clamp(depth,aoclamp,1.0)+(noise.x*(1.0-noise.x));',
'float h = (1.0 / height)/clamp(depth,aoclamp,1.0)+(noise.y*(1.0-noise.y));',
'float pw = 0.0;',
'float ph = 0.0;',
'float ao = 0.0;',
'float dl = PI * (3.0 - sqrt(5.0));',
'float dz = 1.0 / float(samples);',
'float l = 0.0;',
'float z = 1.0 - dz/2.0;',
'for (int i = 0; i < 64; i++)',
'{',
'if (i > samples) break;',
'float r = sqrt(1.0 - z);',
'pw = cos(l) * r;',
'ph = sin(l) * r;',
'ao += calAO(depth,pw*w,ph*h);',
'z = z - dz;',
'l = l + dl;',
'}',
'ao /= float(samples);',
'ao *= strength;',
'ao = 1.0-ao;',
'if (mist)',
'{',
'ao = mix(ao, 1.0, doMist());',
'}',
'vec3 final = vec3(depth);',
'gl_FragColor = vec4(final,1.0);',
'}',
].join('\n');
WAGNER.shaders['symetric-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform float xReverse;',
'uniform float yReverse;',
'uniform float xMirror;',
'uniform float yMirror;',
'uniform float angle;',
'uniform vec2 mirrorCenter;',
'vec2 nvUv;',
'void main() {',
'nvUv = vUv;',
'if (xReverse == 1.) {',
'nvUv.x = (1.0 - vUv.x );',
'if(xMirror == 1.) {',
'if(vUv.x < 0.5) {',
'nvUv.x = 1.0 - (nvUv.x) - (0.5 - mirrorCenter.x ) ;',
'}',
'else {',
'nvUv.x = nvUv.x - (0.5 - mirrorCenter.x);',
'}',
'}',
'}',
'else if(xMirror == 1.) {',
'if(vUv.x < 0.5) {',
'nvUv.x = 1.0 - (nvUv.x) - (0.5 - mirrorCenter.x ) ;',
'}',
'else {',
'nvUv.x = nvUv.x - (0.5 - mirrorCenter.x);',
'}',
'}',
'if (yReverse == 1.) {',
'nvUv.y = (1.0 - vUv.y );',
'if(yMirror == 1.) {',
'if(vUv.y < 0.5) {',
'nvUv.y = 1.0 - (nvUv.y) - (0.5 - mirrorCenter.y ) ;',
'}',
'else {',
'nvUv.y = nvUv.y - (0.5 - mirrorCenter.y);',
'}',
'}',
'}',
'else if(yMirror == 1.) {',
'if(vUv.y < 0.5) {',
'nvUv.y = 1.0 - (nvUv.y) - (0.5 - mirrorCenter.y ) ;',
'}',
'else {',
'nvUv.y = nvUv.y - (0.5 - mirrorCenter.y);',
'}',
'}',
'float sin_factor = sin(angle);',
'float cos_factor = cos(angle);',
'vec2 origin = vec2(0.5 ,0.5);',
'vec2 temp = (nvUv - origin);',
'temp = temp * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);',
'nvUv = (temp + origin);',
'gl_FragColor = texture2D( tInput, nvUv );',
'gl_FragColor.rgb = gl_FragColor.rgb;',
'}',
].join('\n');
WAGNER.shaders['toon-fs'] = [
'uniform vec3 resolution;',
'uniform sampler2D tInput;',
'varying vec2 vUv;',
'#define HueLevCount 6',
'#define SatLevCount 7',
'#define ValLevCount 4',
'float HueLevels[HueLevCount];',
'float SatLevels[SatLevCount];',
'float ValLevels[ValLevCount];',
'vec3 RGBtoHSV( float r, float g, float b) {',
'float minv, maxv, delta;',
'vec3 res;',
'minv = min(min(r, g), b);',
'maxv = max(max(r, g), b);',
'res.z = maxv;',
'delta = maxv - minv;',
'if( maxv != 0.0 )',
'res.y = delta / maxv;',
'else {',
'res.y = 0.0;',
'res.x = -1.0;',
'return res;',
'}',
'if( r == maxv )',
'res.x = ( g - b ) / delta;',
'else if( g == maxv )',
'res.x = 2.0 + ( b - r ) / delta;',
'else',
'res.x = 4.0 + ( r - g ) / delta;',
'res.x = res.x * 60.0;',
'if( res.x < 0.0 )',
'res.x = res.x + 360.0;',
'return res;',
'}',
'vec3 HSVtoRGB(float h, float s, float v ) {',
'int i;',
'float f, p, q, t;',
'vec3 res;',
'if( s == 0.0 ) {',
'res.x = v;',
'res.y = v;',
'res.z = v;',
'return res;',
'}',
'h /= 60.0;',
'i = int(floor( h ));',
'f = h - float(i);',
'p = v * ( 1.0 - s );',
'q = v * ( 1.0 - s * f );',
't = v * ( 1.0 - s * ( 1.0 - f ) );',
'if (i==0) {',
'res.x = v;',
'res.y = t;',
'res.z = p;',
'} else if (i==1) {',
'res.x = q;',
'res.y = v;',
'res.z = p;',
'} else if (i==2) {',
'res.x = p;',
'res.y = v;',
'res.z = t;',
'} else if (i==3) {',
'res.x = p;',
'res.y = q;',
'res.z = v;',
'} else if (i==4) {',
'res.x = t;',
'res.y = p;',
'res.z = v;',
'} else if (i==5) {',
'res.x = v;',
'res.y = p;',
'res.z = q;',
'}',
'return res;',
'}',
'float nearestLevel(float col, int mode) {',
'if (mode==0) {',
'for (int i =0; i<HueLevCount-1; i++ ) {',
'if (col >= HueLevels[i] && col <= HueLevels[i+1]) {',
'return HueLevels[i+1];',
'}',
'}',
'}',
'if (mode==1) {',
'for (int i =0; i<SatLevCount-1; i++ ) {',
'if (col >= SatLevels[i] && col <= SatLevels[i+1]) {',
'return SatLevels[i+1];',
'}',
'}',
'}',
'if (mode==2) {',
'for (int i =0; i<ValLevCount-1; i++ ) {',
'if (col >= ValLevels[i] && col <= ValLevels[i+1]) {',
'return ValLevels[i+1];',
'}',
'}',
'}',
'}',
'float avg_intensity(vec4 pix) {',
'return (pix.r + pix.g + pix.b)/3.;',
'}',
'vec4 get_pixel(vec2 coords, float dx, float dy) {',
'return texture2D(tInput,coords + vec2(dx, dy));',
'}',
'float IsEdge(in vec2 coords){',
'float dxtex = 1.0 / resolution.x ;',
'float dytex = 1.0 / resolution.y ;',
'float pix[9];',
'int k = -1;',
'float delta;',
'float pix0 = avg_intensity(get_pixel(coords,-1.0*dxtex, -1.0*dytex));',
'float pix1 = avg_intensity(get_pixel(coords,-1.0*dxtex, 0.0*dytex));',
'float pix2 = avg_intensity(get_pixel(coords,-1.0*dxtex, 1.0*dytex));',
'float pix3 = avg_intensity(get_pixel(coords,0.0*dxtex, -1.0*dytex));',
'float pix4 = avg_intensity(get_pixel(coords,0.0*dxtex, 0.0*dytex));',
'float pix5 = avg_intensity(get_pixel(coords,0.0*dxtex, 1.0*dytex));',
'float pix6 = avg_intensity(get_pixel(coords,1.0*dxtex, -1.0*dytex));',
'float pix7 = avg_intensity(get_pixel(coords,1.0*dxtex, 0.0*dytex));',
'float pix8 = avg_intensity(get_pixel(coords,1.0*dxtex, 1.0*dytex));',
'delta = (abs(pix1-pix7)+',
'abs(pix5-pix3) +',
'abs(pix0-pix8)+',
'abs(pix2-pix6)',
')/4.;',
'return clamp(5.5*delta,0.0,1.0);',
'}',
'void main(void)',
'{',
'HueLevels[0] = 0.0;',
'HueLevels[1] = 80.0;',
'HueLevels[2] = 160.0;',
'HueLevels[3] = 240.0;',
'HueLevels[4] = 320.0;',
'HueLevels[5] = 360.0;',
'SatLevels[0] = 0.0;',
'SatLevels[1] = 0.1;',
'SatLevels[2] = 0.3;',
'SatLevels[3] = 0.5;',
'SatLevels[4] = 0.6;',
'SatLevels[5] = 0.8;',
'SatLevels[6] = 1.0;',
'ValLevels[0] = 0.0;',
'ValLevels[1] = 0.3;',
'ValLevels[2] = 0.6;',
'ValLevels[3] = 1.0;',
'vec4 colorOrg = texture2D( tInput, vUv );',
'vec3 vHSV =  RGBtoHSV(colorOrg.r,colorOrg.g,colorOrg.b);',
'vHSV.x = nearestLevel(vHSV.x, 0);',
'vHSV.y = nearestLevel(vHSV.y, 1);',
'vHSV.z = nearestLevel(vHSV.z, 2);',
'float edg = IsEdge(vUv);',
'vec3 vRGB = (edg >= 0.3)? vec3(0.0,0.0,0.0):HSVtoRGB(vHSV.x,vHSV.y,vHSV.z);',
'gl_FragColor = vec4(vRGB.x,vRGB.y,vRGB.z,1.0);',
'}',
].join('\n');
WAGNER.shaders['vignette-fs'] = [
'uniform sampler2D tInput;',
'uniform float falloff;',
'uniform float amount;',
'varying vec2 vUv;',
'void main() {',
'vec4 color = texture2D(tInput, vUv);',
'float dist = distance(vUv, vec2(0.5, 0.5));',
'color.rgb *= smoothstep(0.8, falloff * 0.799, dist * (amount + falloff));',
'gl_FragColor = color;',
'}',
].join('\n');
WAGNER.shaders['vignette2-fs'] = [
'varying vec2 vUv;',
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform float reduction;',
'uniform float boost;',
'void main() {',
'vec4 color = texture2D( tInput, vUv );',
'vec2 center = resolution * 0.5;',
'float vignette = distance( center, gl_FragCoord.xy ) / resolution.x;',
'vignette = boost - vignette * reduction;',
'color.rgb *= vignette;',
'gl_FragColor = color;',
'}',
].join('\n');
WAGNER.shaders['vr-compose-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 resolution;',
'uniform sampler2D leftEyeTexture;',
'uniform sampler2D rightEyeTexture;',
'varying vec2 vUv;',
'void main(void) {',
'if( vUv.x < .5 ) {',
'gl_FragColor = texture2D( leftEyeTexture, vUv * vec2( 2., 1. ) );',
'} else {',
'gl_FragColor = texture2D( rightEyeTexture, vUv * vec2( 2., 1. ) - vec2( 1., 0. ) );',
'}',
'}',
].join('\n');
WAGNER.shaders['zoom-blur-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 center;',
'uniform float strength;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}',
'void main(){',
'vec4 color=vec4(0.0);',
'float total=0.0;',
'vec2 toCenter=center-vUv*resolution;',
'float offset=random(vec3(12.9898,78.233,151.7182),0.0);',
'for(float t=0.0;t<=40.0;t++){',
'float percent=(t+offset)/40.0;',
'float weight=4.0*(percent-percent*percent);',
'vec4 sample=texture2D(tInput,vUv+toCenter*percent*strength/resolution);',
'sample.rgb*=sample.a;',
'color+=sample*weight;',
'total+=weight;',
'}',
'gl_FragColor=color/total;',
'gl_FragColor.rgb/=gl_FragColor.a+0.00001;',
'}',
].join('\n');
WAGNER.shaders['zoom-blur2-fs'] = [
'uniform sampler2D tInput;',
'uniform vec2 center;',
'uniform float strength;',
'uniform vec2 resolution;',
'varying vec2 vUv;',
'void main() {',
'vec4 sum = vec4( 0. );',
'vec2 toCenter = center - vUv * resolution;',
'vec2 inc = toCenter * strength / resolution;',
'float boost = 2.;',
'inc = center / resolution - vUv;',
'sum += texture2D( tInput, ( vUv - inc * 4. ) ) * 0.051;',
'sum += texture2D( tInput, ( vUv - inc * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv - inc * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv - inc * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + inc * 0. ) ) * 0.1633;',
'sum += texture2D( tInput, ( vUv + inc * 1. ) ) * 0.1531;',
'sum += texture2D( tInput, ( vUv + inc * 2. ) ) * 0.12245;',
'sum += texture2D( tInput, ( vUv + inc * 3. ) ) * 0.0918;',
'sum += texture2D( tInput, ( vUv + inc * 4. ) ) * 0.051;',
'gl_FragColor = sum;',
'}',
].join('\n');
WAGNER.shaders['basic-vs'] = [
'varying vec2 vUv;',
'varying vec3 vNormal;',
'void main() {',
'vUv = uv;',
'vNormal = normalMatrix * normal;',
'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
'}',
].join('\n');
WAGNER.shaders['orto-vs'] = [
'varying vec2 vUv;',
'void main() {',
'vUv = uv;',
'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
'}',
].join('\n');
WAGNER.shaders['packed-depth-vs'] = [
'varying float depth;',
'uniform float mNear;',
'uniform float mFar;',
'void main() {',
'vec4 viewPos = vec4( modelViewMatrix * vec4( position, 1.0 ) );',
'depth = 1. - ( mNear + viewPos.z ) / ( mNear - mFar );',
'vec3 vPosition = vec4( modelViewMatrix * vec4( position, 1.0 ) ).xyz;',
'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
'depth = -viewPos.z;',
'depth = (-viewPos.z-mNear)/(mFar-mNear);',
'}',
].join('\n');

	this.WAGNER = WAGNER;
}).call(this);
